<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>卢克</title>
    <link href="http://geeklu.com/feed/" rel="self" />
    <link href="http://geeklu.com" />
    <lastBuildDate>2013-06-13T18:01:39-07:00</lastBuildDate>
    <webMaster>kejinlu@gmail.com</webMaster>
    
    <item>
      <title>Discourse的自动化部署</title>
      <link href="http://geeklu.com/2013/05/discourse-install-guide/"/>
      <pubDate>2013-05-25T00:00:00-07:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/05/discourse-install-guide</guid>
      <content:encoded><![CDATA[<blockquote><p>大家可以到这里来讨论 Discourse的安装  <a href="http://www.mydiscourse.org/t/discourse/27">http://www.mydiscourse.org/t/discourse/27</a></p></blockquote>

<p><a href="http://discourse.org/">Discourse</a>是一个开源的论坛程序，由Stack Overflow的联合创始人之一Jeff Atwood在离开Stack Overflow后组队创建。他们的目标很宏伟，就是创建一个面向未来十年的论坛程序。具体的一些论坛的特性可以到其官网上查看，这里主要讨论一些其技术相关的东西。
Discourse的源码托管在github上,<a href="https://github.com/discourse/discourse">https://github.com/discourse/discourse</a>，使用了以下一些相关技术：</p>

<ul>
<li>Ruby on Rails ，Discourse的后端是一个rails的app,RESTful的api，返回JSON格式的数据</li>
<li>Ember.js ，Discourse的前端是一个Ember.js的app，和rails的api进行交互，他们使用这个Ember.js的原因可以参考这篇博文<a href="http://eviltrout.com/2013/02/10/why-discourse-uses-emberjs.html">http://eviltrout.com/2013/02/10/why-discourse-uses-emberjs.html</a>,此博主在Discourse项目中主要担任前端开发工作，他的观点就是如果一个web应用是一个强交互应用的话，那么使用Client MVC的js框架将利大于弊</li>
<li>PostgreSQL ， 主要的数据都使用PostgreSQL进行存储，这个具有学院派风格的数据库经过多年的发展，稳定性，性能都非常不错，功能全面也是其一大特色。</li>
<li>Redis ，使用Redis这个kv数据库用于任务队列等功能</li>
</ul>


<p>如果你想使用Discourse搭建一个论坛，那么一个虚拟主机（VPS）是必不可少的了。本文所使用的主机是在Digital Ocean上申请的，机房选择的是旧金山，国内的访问速度还可以，我是比较熟悉Debian系（比如Debian，Ubuntu...）的Linux发行版本，安装软件直接apt-get解决，非常的方便。所以就选了Debian 7.0 x32 Server，512MB Ram，20GB SSD Disk，不过Discourse官方建议的最低内存是1G。  <br/>
<br>
应用的部署使用了一个ruby写的叫做<a href="https://github.com/capistrano/capistrano">Capistrano</a>的工具，它是一个远程自动部署的工具，支持插件比如这次就使用了一个Capistrano的rbenv插件。  <br/>
Capistrano的使用中涉及到两方：一方是客户端，也就是发起运行Capistrano的一方，Capistrano的配置文件都在客户端；另一方是服务器端，也就是最终应用部署的目标容器。我们在客户端中配置好Capistrano以及发布的脚本，然后运行之，Capistrano便会根据脚本通过ssh连接到服务器上进行部署的各项工作，这些步骤无需我们直接操作，我们只需要看着命令行中输出的log便可。</p>

<h3>一.服务器端的各项准备工作</h3>

<p>创建好虚拟主机后服务器端的一些工作</p>

<h4>0.准备工作</h4>

<p>更新系统：</p>

<pre><code>apt-get update
apt-get upgrade
apt-get install vim #默认的vi不太好用,你也可以选择别的编辑器比如nano
</code></pre>

<p>确认下hostname</p>

<pre><code>vi /etc/hosts #比如 127.0.0.1       localhost mydiscourse.org
</code></pre>

<h4>1.创建交换区</h4>

<p>有些虚拟机提供商可能默认就创建好交换区了，你可以通过free命令来查看，如果free的结果中看到类似如下这一行的时候，说明已经存在swap分区了</p>

<pre><code>    Swap:       524284      23968     500316
</code></pre>

<p>swap分区的作用就是当物理内存不够用的时候，系统将物理内存中长时间没有活动的部分转移到swap分区中，以腾出更多的内存供应用使用。当某个程序需要用到swap分区中的内容的时候，在从swap分区中转移出来。
Digital Ocean默认是没有帮你创建好交换分区的，创建的方式如下：</p>

<pre><code>sudo dd if=/dev/zero of=/swapfile bs=1024 count=512k
sudo mkswap /swapfile
sudo swapon /swapfile
</code></pre>

<p>然后使用vim编辑/etc/fstab，添加下面这行</p>

<pre><code>/swapfile       none    swap    sw      0       0
</code></pre>

<p>为了安全，得修改swapfile的权限</p>

<pre><code>sudo chown root:root /swapfile
sudo chmod 0600 /swapfile
</code></pre>

<p>最后再次通过free命令确认下交换分区是否创建成功。</p>

<h4>2.创建发布用户</h4>

<p>在Linux中，用户管理是一个和系统安全息息相关的问题，所以控制好用户的权限非常的重要。
首先在服务器上需要创建一个专门用于Capistrano发布的账户，我们叫他deploy user,并且将账户的登录方式限制为公私钥认证的方式，禁掉密码认证的登录方式（甚至可以附带关闭root ssh登录系统的权限），这些设置都是在sshd的配置文件中进行设置。
一开始是root登录，这时你需要增加一个deploy user，我们就假设名字为 <code>apps</code></p>

<pre><code>adduser apps #增加一个用户 apps
adduser apps sudo #将apps用户加到sudo组，使其可以使用sudo
</code></pre>

<p>这个时候你可以在客户端通过apps用户进行登录了
要设置ssh验证方式，首先得在客户端也就是本机（desktop）上生成密钥对（如果你之前已经有了可以跳过此步）</p>

<pre><code>ssh-keygen
</code></pre>

<p>这个时候会在~/.ssh 目录下生成了两个文件 id_rsa 和 id_rsa.pub，前者为私有，后者为公钥，你需要将公钥内容加到服务器端对应用户的 <code>~/.ssh/authorized_keys</code> 文件中，如果authorized_keys不存在则你需要创建一下。
然后为了安全性 设置下相关目录的权限</p>

<pre><code>chown -R apps:apps .ssh
chmod 700 .ssh
chmod 600 .ssh/authorized_keys
</code></pre>

<p>这个时候你可以从客户端直接ssh连 过去而不用输入用户密码了，假设这个时候你以apps登录下，我们再把密码验证登录验证的方式关掉。</p>

<pre><code>#设置成 PasswordAuthentication no    以及 PermitRootLogin no
sudo vi /etc/ssh/sshd_config

#重启 sshd服务
sudo service ssh restart 
</code></pre>

<h4>3.安装必要的软件</h4>

<pre><code>#编译ruby所需的基础库
sudo apt-get install build-essential openssl libreadline6 libreadline6-dev \
         curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev \
         sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev libgdbm-dev \
         ncurses-dev automake libtool bison subversion pkg-config libffi-dev
#安装nginx
sudo apt-get install nginx
#安装PostgreSQL redis
sudo apt-get install postgresql-9.1 postgresql-contrib-9.1 redis-server \
                     libxml2-dev libxslt-dev libpq-dev make g++
</code></pre>

<p>创建好数据的角色和数据库</p>

<pre><code>sudo -u postgres createuser apps -s -P
createdb -U apps discourse_production
</code></pre>

<p>由于Discourse有邮件发送的需求，如果你想使用系统本身来发邮件，那么你还得安装sendmail</p>

<pre><code>apt-get install sendmail    
</code></pre>

<p><br></p>

<h3>二.客户端的工作</h3>

<h4>1.客户端安装基础软件</h4>

<p>安装git，如果你是使用Linux那么直接使用相关的包管理软件进行安装，如果你使用的是Mac那么可以使用macprot或者brew这些第三方的包管理软件进行安装。当然如果你要使用源码编译的方式安装也是可以的。
安装ruby，你可以直接安装（包管理软件安装或者源码编译），也可以通过ruby版本管理的软件进行间接安装，比如rvm，rbenv。我这里选择了rbenv。
如果你是Linux你得确保编译所需的软件包都安装就绪</p>

<pre><code>sudo apt-get install build-essential openssl libreadline6 libreadline6-dev \
         curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev \
         sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev libgdbm-dev \
         ncurses-dev automake libtool bison subversion pkg-config libffi-dev
</code></pre>

<p>如果你是Mac，那么XCode以及XCode命令行工具你得安装就位。</p>

<p>安装rbenv以及通过rbenv安装ruby</p>

<pre><code>#安装rbenv
git clone git://github.com/sstephenson/rbenv.git ~/.rbenv
echo 'export PATH="$HOME/.rbenv/bin:$PATH"' &gt;&gt; ~/.bash_profile
echo 'eval "$(rbenv init -)"' &gt;&gt; ~/.bash_profile
exec $SHELL -l

#安装rbenv的ruby-build插件，方便ruby版本的安装
git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
#安装rbenv的rehash插件，安装了新的gem后再也不用运行rbenv rehash了:)
git clone https://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash

#安装ruby-2.0.0-p195以及bundler
rbenv install 2.0.0-p195; 
rbenv global 2.0.0-p195
gem install bundler
</code></pre>

<h4>2.git库的相关操作</h4>

<p>如果你想自己做一些自定义的开发工作或者想为discourse这个开源项目贡献自己的代码，那么你去注册一个github的账号是必不可少的了。
然后从 <a href="https://github.com/discourse/discourse">https://github.com/discourse/discourse</a> fork一个git库出来，比如我fork出来的地址为 <a href="https://github.com/kejinlu/discourse">https://github.com/kejinlu/discourse</a></p>

<pre><code>#克隆远程库到本地
git clone git@github.com:kejinlu/discourse.git
cd discourse
#增加上游库,以便将上游的更新合并过来
git remote add upstream git@github.com:discourse/discourse.git 
</code></pre>

<h4>3.准备Discourse生产环境所需的配置文件</h4>

<h5>config/database.yml</h5>

<p>数据库的配置文件，主要配置数据库的用户名密码，以及相关hostname</p>

<pre><code>cp database.yml.production-sample config/database.yml 
#然后对用户名密码以及对生产环境对应的host_names进行修改
vi config/database.yml 
</code></pre>

<h5>config/redis.yml</h5>

<p>配置文件可以直接使用样例</p>

<pre><code>cp redis.yml.sample redis.yml #使用样例的配置即可，无需修改
</code></pre>

<h5>environments/production.rb</h5>

<p>次配置文件主要需要修改就是邮件发送的配置，如果你不想使用操作系统中的sendmail进行发送邮件,你可以选择第三方的smtp服务，
比如我就是使用gmail的smtp进行发送的，相关配置如下：</p>

<pre><code>config.action_mailer.delivery_method = :smtp
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = true
config.action_mailer.smtp_settings = {
 :address              =&gt; "smtp.gmail.com",
 :port                 =&gt; 587,
 :domain               =&gt; 'mail.google.com',
 :user_name            =&gt; 'info.mydiscourse@gmail.com',
 :password             =&gt; 'xxxxxxxx',
 :authentication       =&gt; 'plain',
 :enable_starttls_auto =&gt; true  }

 #config.action_mailer.delivery_method = :sendmail
 #config.action_mailer.sendmail_settings = {arguments: '-i'}
</code></pre>

<h5>initializers/secret_token.rb</h5>

<p>这个文件是rails要用的，默认就存在了，只不过用于开发环境的，你需要生成一个新的secret并对这个文件进行修改</p>

<pre><code>bundle exec rake secret
</code></pre>

<p>将生成的字符串用到<code>initializers/secret_token.rb</code>文件中</p>

<p>最后这个文件除了注释掉的只剩下一行</p>

<pre><code>Discourse::Application.config.secret_token = "你生成的token贴到这里"
</code></pre>

<h5>config/thin.yml</h5>

<p>是用于thin的配置文件，</p>

<pre><code>cp config/thin.yml.sample config/thin.yml
</code></pre>

<p>在config/thin.yml最后加上一行</p>

<pre><code>onebyone: true
</code></pre>

<p>当然你也可以自己设置server的数量，一个server在运行的时候对应一个thin的进程，如果你的内存有线可以适当的减少server的数量，比如我设置成了2</p>

<pre><code>---
chdir: /home/apps/discourse/current
environment: production
address: 0.0.0.0
port: 3000
timeout: 30
log: /home/apps/discourse/shared/log/thin.log
pid: /home/apps/discourse/shared/pids/thin.pid
socket: /home/apps/discourse/shared/sockets/thin.sock
max_conns: 1024
max_persistent_conns: 100
require: []
wait: 30
servers: 2
daemonize: true
onebyone: true
</code></pre>

<h5>config/nginx.conf</h5>

<pre><code>cp config/nginx.conf.sample config/nginx.conf
</code></pre>

<p>这是nginx的配置文件，下面是我的配置，upstream里面内容和thin的配置对应,还要记得修改server_name以及location的root的位置</p>

<pre><code>upstream discourse {
  server unix:///home/apps/discourse/shared/sockets/thin.0.sock;
  server unix:///home/apps/discourse/shared/sockets/thin.1.sock;
}

server {

  listen 80;
  gzip on;
  gzip_min_length 1000;
  gzip_types application/json text/css application/x-javascript;

  server_name mydiscourse.org;

  sendfile on;

  keepalive_timeout 65;

  location / {
    root /home/apps/discourse/current/public;

    location ~ ^/t\/[0-9]+\/[0-9]+\/avatar {
      expires 1d;
      add_header Cache-Control public;
      add_header ETag "";
    }

    location ~ ^/assets/ {
      expires 1y;
      add_header Cache-Control public;
      add_header ETag "";
      break;
    }

    proxy_set_header  X-Real-IP  $remote_addr;
    proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header  X-Forwarded-Proto $scheme;
    proxy_set_header  Host $http_host;


    # If the file exists as a static file serve it directly without
    # running all the other rewite tests on it
    if (-f $request_filename) {
      break;
    }

    if (!-f $request_filename) {
      proxy_pass http://discourse;
      break;
    }

  }

}
</code></pre>

<p>由于上面的一些配置中涉及到一些敏感信息，你不不能将其放到public的库中，要不放到私有库中，要么将这些敏感文件加入git的ignore。如果将上述的文件加入ignore的话，那么在下面的deploy脚本中需要将本地的配置在部署的过程中拷贝到目标服务器中，作为生产环境的配置文件，如果你把正式的配置文件都放到了私有的库中，那么这些配置文件其实就没有必要从客户端再拷贝了，下文的deploy.rb脚本中就有从本地拷贝这些配置的过程。</p>

<h4>4.配置Capistrano</h4>

<p>往Gemfile中加入两行</p>

<pre><code>gem 'capistrano', require: nil
gem 'capistrano-rbenv', require: nil
</code></pre>

<p>增加Capfile</p>

<pre><code>cp Capfile.sample Capfile
</code></pre>

<p>创建config/deploy.rb</p>

<pre><code># Require the necessary Capistrano recipes
require 'capistrano-rbenv'
require 'bundler/capistrano'
require 'sidekiq/capistrano'

# Repository settings, forked to an outside copy
set :repository, 'git://github.com/kejinlu/discourse.git'
set :deploy_via, :remote_cache
set :branch, fetch(:branch, 'master')
set :scm, :git

ssh_options[:keys] = [File.join(ENV["HOME"], ".ssh", "id_rsa")]
ssh_options[:forward_agent] = true

# General Settings
set :deploy_type, :deploy
default_run_options[:pty] = true


# Server Settings
set :user, 'apps'
set :use_sudo, false
set :rails_env, :production
set :rbenv_ruby_version, '2.0.0-p195'

role :app, 'mydiscourse.org', primary: true
role :db,  'mydiscourse.org', primary: true
role :web, 'mydiscourse.org', primary: true

# Application Settings
set :application, 'discourse'
set :deploy_to, "/home/#{user}/#{application}"

# Keep your bundle up to date!
#after "deploy:setup" do
#  run "cd #{current_path} &amp;&amp; bundle install"
#end

namespace :deploy do
  # Tasks to start, stop and restart thin. This takes Discourse's
  # recommendation of changing the RUBY_GC_MALLOC_LIMIT.
  desc 'Start thin servers'
  task :start, :roles =&gt; :app, :except =&gt; { :no_release =&gt; true } do
    run "cd #{current_path} &amp;&amp; RUBY_GC_MALLOC_LIMIT=90000000 bundle exec thin -C config/thin.yml start", :pty =&gt; false
  end

  desc 'Stop thin servers'
  task :stop, :roles =&gt; :app, :except =&gt; { :no_release =&gt; true } do
    run "cd #{current_path} &amp;&amp; bundle exec thin -C config/thin.yml stop"
  end

  desc 'Restart thin servers'
  task :restart, :roles =&gt; :app, :except =&gt; { :no_release =&gt; true } do
    run "cd #{current_path} &amp;&amp; RUBY_GC_MALLOC_LIMIT=90000000 bundle exec thin -C config/thin.yml restart"
  end

  # Sets up several shared directories for configuration and thin's sockets,
  # as well as uploading your sensitive configuration files to the serer.
  # The uploaded files are ones I've removed from version control since my
  # project is public. This task also symlinks the nginx configuration so, if
  # you change that, re-run this task.
  task :setup_config, roles: :app do
    run  "mkdir -p #{shared_path}/config/initializers"
    run  "mkdir -p #{shared_path}/config/environments"
    run  "mkdir -p #{shared_path}/sockets"
    put  File.read("config/database.yml"), "#{shared_path}/config/database.yml"
    put  File.read("config/redis.yml"), "#{shared_path}/config/redis.yml"
    put  File.read("config/environments/production.rb"), "#{shared_path}/config/environments/production.rb"
    put  File.read("config/initializers/secret_token.rb"), "#{shared_path}/config/initializers/secret_token.rb"
    put  File.read("config/thin.yml"), "#{shared_path}/config/thin.yml"
    put  File.read("config/nginx.conf"), "#{shared_path}/config/nginx.conf"
    sudo "ln -nfs #{shared_path}/config/nginx.conf /etc/nginx/sites-enabled/#{application}"
    puts "Now edit the config files in #{shared_path}."
  end

  # Symlinks all of your uploaded configuration files to where they should be.
  task :symlink_config, roles: :app do
    run  "ln -nfs #{shared_path}/config/database.yml #{release_path}/config/database.yml"
    run  "ln -nfs #{shared_path}/config/newrelic.yml #{release_path}/config/newrelic.yml"
    run  "ln -nfs #{shared_path}/config/redis.yml #{release_path}/config/redis.yml"
    run  "ln -nfs #{shared_path}/config/environments/production.rb #{release_path}/config/environments/production.rb"
    run  "ln -nfs #{shared_path}/config/initializers/secret_token.rb #{release_path}/config/initializers/secret_token.rb"
    run  "ln -nfs #{shared_path}/config/thin.yml #{release_path}/config/thin.yml"
  end
end

after "deploy:setup", "deploy:setup_config"
after "deploy:finalize_update", "deploy:symlink_config"

# Tasks to start/stop/restart the clockwork process.
namespace :clockwork do
  desc "Start clockwork"
  task :start, :roles =&gt; [:app] do
    run "cd #{current_path} &amp;&amp; RAILS_ENV=#{rails_env} bundle exec clockworkd -c #{current_path}/config/clock.rb --pid-dir #{shared_path}/pids --log --log-dir #{shared_path}/log start"
  end

  task :stop, :roles =&gt; [:app] do
    run "cd #{current_path} &amp;&amp; RAILS_ENV=#{rails_env} bundle exec clockworkd -c #{current_path}/config/clock.rb --pid-dir #{shared_path}/pids --log --log-dir #{shared_path}/log stop"
  end

  task :restart, :roles =&gt; [:app] do
    run "cd #{current_path} &amp;&amp; RAILS_ENV=#{rails_env} bundle exec clockworkd -c #{current_path}/config/clock.rb --pid-dir #{shared_path}/pids --log --log-dir #{shared_path}/log restart"
  end
end

after  "deploy:stop",    "clockwork:stop"
after  "deploy:start",   "clockwork:start"
before "deploy:restart", "clockwork:restart"

namespace :db do
  desc 'Seed your database for the first time'
  task :seed do
    run "cd #{current_path} &amp;&amp; psql -d discourse_production &lt; pg_dumps/production-image.sql"
  end
end

after  'deploy:update_code', 'deploy:migrate'
</code></pre>

<h4>5.运行Capistrano</h4>

<p>初次安装部署</p>

<pre><code>bundle install
cap deploy:setup
cap deploy:cold #第一次运行之后更新重启的时候只需要 cap deploy 便可
</code></pre>

<p>升级部署</p>

<pre><code>git fetch upstream
git merge upstream/master
git push origin master
cap deploy
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Git修订版本</title>
      <link href="http://geeklu.com/2013/05/git-revisions/"/>
      <pubDate>2013-05-09T00:00:00-07:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/05/git-revisions</guid>
      <content:encoded><![CDATA[<p>在git中修订版本其实就是commit对象的名字，这个名字可以直接是sha1的哈希或者指向这个哈希的引用（比如分支或者tag）。git使用中，修订版本或者修订版本范围的指定是一个非常重要的知识点，因为很多git命令都需要接收这样的参数，即修订版本或者修订版本的范围。
指定修订版本往往是为了从这个指定的修订版本开始向回遍历所有的修订版本进行相关操作，而指定修订版本范围则是为了只对范围中的修订版本进行单独操作。
关于修订版本及其范围的指定方式可以在这里找到：<a href="https://www.kernel.org/pub/software/scm/git/docs/gitrevisions.html">https://www.kernel.org/pub/software/scm/git/docs/gitrevisions.html</a>。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Git reflog 机制</title>
      <link href="http://geeklu.com/2013/04/git-reflog/"/>
      <pubDate>2013-04-26T00:00:00-07:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/04/git-reflog</guid>
      <content:encoded><![CDATA[<h3>使用git reflog查看引用变化</h3>

<p><a href="https://www.kernel.org/pub/software/scm/git/docs/git-reflog.html">git reflog</a>是对reflog进行管理的命令，那么什么是reflog呢？ <br/>
reflog是git用来记录引用变化的一种机制，比如记录分支的变化或者是HEAD引用的变化。
比如在某git库中运行git reflog,当git reflog命令不指定引用的时候默认列出HEAD的reflog。</p>

<pre><code>2ab4043 (HEAD, refs/heads/master, refs/heads/a) HEAD@{0}: checkout: moving from master to a
2ab4043 (HEAD, refs/heads/master, refs/heads/a) HEAD@{1}: commit (merge): Merge branch 'mybranch'
bf98582 HEAD@{2}: rebase: aborting
bf98582 HEAD@{3}: checkout: moving from 7e9938d9f5b9f7835359ca87da8a329781ed74b6 to master
7e9938d (refs/remotes/origin/mybranch, refs/heads/mybranch) HEAD@{4}: checkout: moving from master to 7e9938d9f5b9f7835359ca87da8a329781ed74b6^0
bf98582 HEAD@{5}: reset: moving to bf985821e12129ea3dc9d4150792b8dae798773c
be93372 (refs/remotes/origin/master) HEAD@{6}: commit: add merge detail to read me
3eeedca HEAD@{7}: commit (merge): Merge branch 'mybranch'
bf98582 HEAD@{8}: reset: moving to bf985821e12129ea3dc9d4150792b8dae798773c
00fa1f0 HEAD@{9}: commit (merge): Merge branch 'mybranch'
bf98582 HEAD@{10}: reset: moving to bf985821e12129ea3dc9d4150792b8dae798773c
663feb9 HEAD@{11}: commit: merge mybranch
bf98582 HEAD@{12}: reset: moving to bf985821e12129ea3dc9d4150792b8dae798773c
aa73004 HEAD@{13}: commit: merge issue
bf98582 HEAD@{14}: commit: modify readme file
cd2eddb HEAD@{15}: checkout: moving from mybranch to master
7e9938d (refs/remotes/origin/mybranch, refs/heads/mybranch) HEAD@{16}: commit: modiy readme add issueFile
cd2eddb HEAD@{17}: checkout: moving from master to mybranch
cd2eddb HEAD@{18}: commit: prepare files
b39fed8 HEAD@{19}: commit (initial): first commit
</code></pre>

<p>这里涉及到一个修订版本引用的语法,比如 HEAD@{0}代表HEAD当前的值，HEAD@{2}代表HEAD两次变化之前的值。详情的语法可以参看这里 <a href="https://www.kernel.org/pub/software/scm/git/docs/gitrevisions.html">https://www.kernel.org/pub/software/scm/git/docs/gitrevisions.html</a>。 <br/>
上面的输出结果为HEAD所有的变化历史，每一条记录包含了变化所对应的git操作，比如commit，checkout，rebase，merge等，以及变化的详情内容。    <br/>
git reflog有时候可以帮助你找到丢失掉的commit，比如你在某个detached HEAD（即不在任何分支只是在某个历史的commit的节点上）的时候进行了一次commit，然后你切换到另一个分支想把刚才的东西合并进来，这个时候突然意识到刚才的那次提交找不到了，这时你就可以通过HEAD@{1}引用到刚才的提交了，或者通过git reflog找到对应commit的sha1值，然后进行merge。
<br></p>

<h3>reflog文件格式</h3>

<p>那么git系统是如何存储reflog的呢？这里继续拿HEAD来举例，git会将变化记录到HEAD对应的reflog文件中，其路径为.git/logs/HEAD，文件是一个纯文本文件。分支的reflog文件都放在.git/logs/refs目录下的子目录中。
下面是HEAD的reflog文件的内容：</p>

<pre><code>0000000000000000000000000000000000000000 b39fed82cd3225eb524f6f0184c0ba49a4f6952c 卢克 &lt;kejinlu@gmail.com&gt; 1366871718 +0800   commit (initial): first commit
b39fed82cd3225eb524f6f0184c0ba49a4f6952c cd2eddb41a632f68b0655366d5ca99f4701bb9b4 卢克 &lt;kejinlu@gmail.com&gt; 1366871885 +0800   commit: prepare files
cd2eddb41a632f68b0655366d5ca99f4701bb9b4 cd2eddb41a632f68b0655366d5ca99f4701bb9b4 卢克 &lt;kejinlu@gmail.com&gt; 1366871950 +0800   checkout: moving from master to mybranch
cd2eddb41a632f68b0655366d5ca99f4701bb9b4 7e9938d9f5b9f7835359ca87da8a329781ed74b6 卢克 &lt;kejinlu@gmail.com&gt; 1366872039 +0800   commit: modiy readme add issueFile
7e9938d9f5b9f7835359ca87da8a329781ed74b6 cd2eddb41a632f68b0655366d5ca99f4701bb9b4 卢克 &lt;kejinlu@gmail.com&gt; 1366872046 +0800   checkout: moving from mybranch to master
cd2eddb41a632f68b0655366d5ca99f4701bb9b4 bf985821e12129ea3dc9d4150792b8dae798773c 卢克 &lt;kejinlu@gmail.com&gt; 1366872107 +0800   commit: modify readme file
bf985821e12129ea3dc9d4150792b8dae798773c aa7300408b6865b105d196c1acf60dc83ffccef1 卢克 &lt;kejinlu@gmail.com&gt; 1366872272 +0800   commit: merge issue
aa7300408b6865b105d196c1acf60dc83ffccef1 bf985821e12129ea3dc9d4150792b8dae798773c 卢克 &lt;kejinlu@gmail.com&gt; 1366872623 +0800   reset: moving to bf985821e12129ea3dc9d4150792b8dae798773c
bf985821e12129ea3dc9d4150792b8dae798773c 663feb94a406a8d3600f2d24bf4dafc565a5f9da 卢克 &lt;kejinlu@gmail.com&gt; 1366872760 +0800   commit: merge mybranch
663feb94a406a8d3600f2d24bf4dafc565a5f9da bf985821e12129ea3dc9d4150792b8dae798773c 卢克 &lt;kejinlu@gmail.com&gt; 1366872810 +0800   reset: moving to bf985821e12129ea3dc9d4150792b8dae798773c
bf985821e12129ea3dc9d4150792b8dae798773c 00fa1f0727bca42305b2a7c5dc53f44c33a17a96 卢克 &lt;kejinlu@gmail.com&gt; 1366872883 +0800   commit (merge): Merge branch 'mybranch'
00fa1f0727bca42305b2a7c5dc53f44c33a17a96 bf985821e12129ea3dc9d4150792b8dae798773c 卢克 &lt;kejinlu@gmail.com&gt; 1366873467 +0800   reset: moving to bf985821e12129ea3dc9d4150792b8dae798773c
bf985821e12129ea3dc9d4150792b8dae798773c 3eeedca7ea0b821088faba84b3157493eae4e13d 卢克 &lt;kejinlu@gmail.com&gt; 1366873579 +0800   commit (merge): Merge branch 'mybranch'
3eeedca7ea0b821088faba84b3157493eae4e13d be933721a15b18605aaf9d4d9f5c5eff3281b9b4 卢克 &lt;kejinlu@gmail.com&gt; 1366874038 +0800   commit: add merge detail to read me
be933721a15b18605aaf9d4d9f5c5eff3281b9b4 bf985821e12129ea3dc9d4150792b8dae798773c 卢克 &lt;kejinlu@gmail.com&gt; 1366882601 +0800   reset: moving to bf985821e12129ea3dc9d4150792b8dae798773c
bf985821e12129ea3dc9d4150792b8dae798773c 7e9938d9f5b9f7835359ca87da8a329781ed74b6 卢克 &lt;kejinlu@gmail.com&gt; 1366882618 +0800   checkout: moving from master to 7e9938d9f5b9f7835359ca87da8a329781ed74b6^0
7e9938d9f5b9f7835359ca87da8a329781ed74b6 bf985821e12129ea3dc9d4150792b8dae798773c 卢克 &lt;kejinlu@gmail.com&gt; 1366882688 +0800   checkout: moving from 7e9938d9f5b9f7835359ca87da8a329781ed74b6 to master
bf985821e12129ea3dc9d4150792b8dae798773c bf985821e12129ea3dc9d4150792b8dae798773c 卢克 &lt;kejinlu@gmail.com&gt; 1366882792 +0800   rebase: aborting
bf985821e12129ea3dc9d4150792b8dae798773c 2ab4043c6c4c9f59e7756cb7fb5df4fdf467fe4b 卢克 &lt;kejinlu@gmail.com&gt; 1366882860 +0800   commit (merge): Merge branch 'mybranch'
2ab4043c6c4c9f59e7756cb7fb5df4fdf467fe4b 2ab4043c6c4c9f59e7756cb7fb5df4fdf467fe4b 卢克 &lt;kejinlu@gmail.com&gt; 1366958770 +0800   checkout: moving from master to a
</code></pre>

<p>从上面HEAD的reflog的log文件的内容可以看到，每一个reflog的entry都包含了变化前commit节点的sha1值以及变化后的commit节点的sha1值，如果你阅读了git的源码你会看到这两个值对应的变量名为osha1（old sha1）和nsha1（new sha1），第一次commit对应变化的old sha1值为全0的特殊值；每一个entry还包含了用户名，email ，变化的时间戳以及变化的具体内容。</p>

<p><br></p>

<h3>reflog高级操作</h3>

<p>在git中一个对象一般都会被别的对象或者引用引用到。如果一个对象不再被任何对象或者引用直接引用到，那么这个对象就成了一个悬空对象dangling object。Dangling object在git库中基本没有大的作用了，如果你不去管它，会根据过期失效的策略最终被垃圾回收机制清理掉。 <br/>
如果从某个引用或者对象开始去遍历对象的有向图，无法达到某个指定对象，那么可以说这个指定对象unreachable from this reference or object。 <br/>
如果一个对象unreachable from任何其他对象和引用，那么它便是悬空对象了。</p>

<p>之前我们提到，reflog entry会记录old sha1，new sha1的值，所以reflog 也算作对这两个sha1对应的对象的引用者。所以有时候虽然某个commit对象无法从任何一个引用引用到，但是它却不是真正的悬空对象，原因就是还有reflog对它的引用。所以有时候为了清理无用的对象，需要删除一些reflog entry。</p>

<p><code>git reflog delete ref@{specifier}</code> 可以用来删除指定的reflog entry，使得它从历史中消失，这个时候reflog并不是引用变化的真实历史了。前面讲了，每一个reflog entry都包含两个sha1，老sha1和新sha1，如果删除中间的某条entry的时候，就相当于断开了这种新老的关联，产生了gap，如何解决这个问题呢？可以在delete的时候加上<code>--rewrite选项</code>，它的作用就是使得删除掉的记录后面的entry的old sha1为现在前一条entry的new sha1值。</p>

<p>还有一种删除reflog entry的方式是使用其过期机制，<code>git reflog expire [--expire=&lt;time&gt;] [--expire-unreachable=&lt;time&gt;] &lt;refs&gt;</code>，如果不指定其中的相关时间的话，则使用git配置的 <code>gc.reflogExpire</code> 和 <code>gc.reflogExpireUnreachable</code>如果配置没有显式的配置则使用默认值，分别为90天和两周。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Git命令介绍及内部机制</title>
      <link href="http://geeklu.com/2013/04/git-keynote/"/>
      <pubDate>2013-04-19T00:00:00-07:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/04/git-keynote</guid>
      <content:encoded><![CDATA[<object width="630" height="500" align="middle" id="reader" codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0" classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"><param value="window" name="wmode"><param value="true" name="allowfullscreen"><param name="allowscriptaccess" value="always"><param value="http://wenku.baidu.com/static/flash/apireader.swf?docurl=http://wenku.baidu.com/play&amp;docid=77512e64b84ae45c3b358c57&amp;title=Git&amp;doctype=pdf&amp;fpn=5&amp;npn=5&amp;readertype=external&catal=0&amp;cdnurl=http://txt.wenku.baidu.com/play" name="movie"><embed width="630" align="middle" height="500" pluginspage="http://www.macromedia.com/go/getflashplayer" type="application/x-shockwave-flash" name="reader" src="http://wenku.baidu.com/static/flash/apireader.swf?docurl=http://wenku.baidu.com/play&amp;docid=77512e64b84ae45c3b358c57&amp;title=Git&amp;doctype=pdf&amp;fpn=5&amp;npn=5&amp;readertype=external&catal=0&amp;cdnurl=http://txt.wenku.baidu.com/play" wmode="window" allowscriptaccess="always" bgcolor="#FFFFFF" ver="9.0.0" allowfullscreen="true"></embed></object>



]]></content:encoded>
    </item>
    
    <item>
      <title>iOS Cookie使用</title>
      <link href="http://geeklu.com/2013/04/ios-cookie/"/>
      <pubDate>2013-04-02T00:00:00-07:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/04/ios-cookie</guid>
      <content:encoded><![CDATA[<p>关于Cookie的标准和原理这里就不细说了，这里只说说在iOS平台下如何进行Cookie相关的编程。  <br/>
和Mac上不同，在iOS平台上各个App都有自己的Cookie，App之间不共享Cookie。  <br/>
一个Cookie对应一个NSHTTPCookie实体，并通过NSHTTPCookieStorage进行管理。  <br/>
那些需要持久化的Cookie是存放在 <code>~/Library/Cookies/Cookies.binarycookies</code> 文件中的，二进制格式。</p>

<p>Cookie生成的有两个途径，一个是访问一个网页，这个网页返回的HTTP Header中有Set-Cookie指令进行Cookie的设置，这里Cookie的本地处理其实是由WebKit进行的；还有一种途径就是客户端通过代码手动设置Cookie。</p>

<pre><code>NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];
[cookieProperties setObject:@"name" forKey:NSHTTPCookieName];
[cookieProperties setObject:@"value" forKey:NSHTTPCookieValue];
[cookieProperties setObject:@"www.taobao.com" forKey:NSHTTPCookieDomain];
[cookieProperties setObject:@"/" forKey:NSHTTPCookiePath];
[cookieProperties setObject:@"0" forKey:NSHTTPCookieVersion];
[cookieProperties setObject:@"30000" forKey:NSHTTPCookieMaximumAge];
NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];
[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
//删除cookie的方法为deleteCookie:
</code></pre>

<p>在通过<code>setCookie:</code>进行设置cookie的时候，会覆盖name,domain,path都相同的cookie的。  <br/>
至于cookie会不会持久化到cookie文件中主要看这个cookie的生命周期，和Max-Age或者Expires有关。</p>

<p><br>
不过NSHTTPCookieStorage存在一个问题，setCookie或者deleteCookie后并不会立即进行持久化，而是有几秒的延迟。如果在持久化之前App接收到SIGKILL信号，App退出，那么会导致cookie相关操作的丢失。在模拟器调试的过程中，XCode重启App的时发给App的就是SIGKILL，不过真正的生产环境中很少有这种情况。 <br/>
但是有时候为了可靠性，我们还是会将cookie信息保存一份到User Defaults，需要用的时候load进来。关于cookie操作丢失的详情可以查看这里<a href="http://openradar.appspot.com/radar?id=2776403">NSHTTPCookieStorage looses cookies on SIGKILL</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Web常识</title>
      <link href="http://geeklu.com/2013/03/web/"/>
      <pubDate>2013-03-25T00:00:00-07:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/03/web</guid>
      <content:encoded><![CDATA[<h3>一.Web起源</h3>

<p>1969年，美国国防高等研究计划署（ ARPA ，Advanced Research Projects Agency ）开始建立一个命名为ARPANET的网络。当初，ARPANET只联结4台主机，从军事要求上是置于美国国防部高级机密的保护之下，从技术上它还不具备向外推广的条件。 <br/>
1983年1月1日，原先ARPANET使用的交流协议NCP（Network Control Protocol）成为历史，TCP/IP开始成为通用协议。 <br/>
1986年，美国国家科学基金会（National Science Foundation）建立了大学之间互联的骨干网络NSFNET，这是互联网历史上重要的一步。  <br/>
<br>
互联网的发展当然也离不开操作系统的发展，起初贝尔实验室给大学研究室提供的UNIX，是附带源码的，各个研究室可以自行修改。1977，Bill Joy（比尔·乔伊，Sun Microsystems联合创始人，03年离开SUN） 伯克利大学的学生，编译发行了 BSD（Berkeley Software Distribution）。BSD UNIX 是第一个包含了网络协议栈库的UNIX（一开始支持的还是NCP协议），这个库也就是熟知的BSD Sockets。通过将套接字与Unix操作系统的文件描述符相整合，使得网络读写数据和读写本地文件一样容易。BSD Sockets几乎成了网络访问的标准，其他系统的Sockets多多少少是基于BSD Sockets修改而来的，即便是Windows中的Winsock也借鉴了BSD Sockets。 <br/>
乔布斯1985年被赶出苹果，后来他创建了NeXT.Inc，并开发出NEXTSTEP操作系统。这个操作系统是基于Mach和BSD（混合内核 Hybrid kernel）的。1988年NeXTSTEP第一个正式发布版本问世了。   <br/>
<br>
至于超文本的概念其实在HTTP之前就已经被提出来了，预言了一种非线性结构的文本，只是一直没有应用到计算机中。  <br/>
1980年中Tim Berners-Lee到CERN工作，几个月间创建一个以超文本系统为基础的项目，方便研究人员分享及更新讯息。同时，他创建了一个原型系统，叫ENQUIRE。
但工作了几个月就离开了CERN，转到一个图形计算相关的公司工作，并在工作中积累了网络编程的经验。  <br/>
1984年，伯纳斯-李以正式员工的身份重返CERN，并于1990年开始着手他构想了多年的万维网以及超文本协议，WorldWideWeb项目，只花了两个月开发在年底开发出来。于是世界上第一个Web出现了,而第一个Web正是构建在NeXTcube工作站上的，运行着NeXTSTEP系统。  <br/>
后来伯纳斯-李创建了非赢利性的万维网联盟W3C。为Web的良性和谐发展做出了巨大的贡献。
<br></p>

<h3>二.浅谈HTTP</h3>

<p>HTTP的全称为Hypertext Transfer Protocol，也就是所谓的超文本传输协议。是一个C/S（客户端/服务器端）结构下的请求响应协议。   <br/>
在HTTP之初，只是用来传输静态内容，一个URL对应网络中的一个文件，不管你是谁，什么时候，用什么浏览器访问，返回的内容都是一样的，所以这是一种没有状态（stateless ）的访问。所以HTTP一开始设计成无状态的也是可以理解的。   <br/>
但是随着Web的不断发展，动态内容的需求出现了，所以状态的必要性显现出来了。现在一般都有Session的概念 ，服务器端一般可以通过以下方式来实现Session:</p>

<ul>
<li>HTTP Cookies</li>
<li>Query string parameters</li>
<li>表单隐藏字段</li>
</ul>


<p><br>
下面我们再来看看HTTP请求响应的过程
当TCP连接成功后，HTTP的请求响应总的来说就分两步:</p>

<blockquote><p>以下数据来自 WireShark抓包的数据</p></blockquote>

<ul>
<li><p>1.发送GET请求</p>

<pre><code>  GET / HTTP/1.1
  Host: www.baidu.com
  Connection: keep-alive
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.172 Safari/537.22
  Accept-Encoding: gzip,deflate,sdch
  Accept-Language: zh-CN,zh;q=0.8
  Accept-Charset: UTF-8,*;q=0.5
  Cookie: BAIDUID=3D028EC08E879EE43F74D73F5C5A3E6D:FG=1; BDUT=btisCE4CE66A884493DB42E76032CA2D85AB13d15f1600c2
</code></pre></li>
<li><p>2.服务器端发送响应</p>

<pre><code>  HTTP/1.1 200 OK
  Date: Fri, 22 Mar 2013 06:54:22 GMT
  Server: BWS/1.0
  Content-Length: 4278
  Content-Type: text/html;charset=utf-8
  Cache-Control: private
  Expires: Fri, 22 Mar 2013 06:54:22 GMT
  Content-Encoding: gzip
  Set-Cookie: H_PS_PSSID=2071_1435_1944_2068_1788; path=/; domain=.baidu.com
  Connection: Keep-Alive
  Content-encoded entity body (gzip): 4278 bytes -&gt; 10329 bytes
</code></pre></li>
</ul>


<p>如果Connection是keep-alive的话，tcp连接不会立即关闭。从HTTP/1.1起，默认都开启了Keep-Alive。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache,Nginx）中设定这个timeout时间。
<br></p>

<h3>三.Web Server</h3>

<p>Web Server 的功能其实很简单，就是接收HTTP请求，并对请求进行响应。  <br/>
Web起初只支持静态的文件，后来为了支持动态的内容，就制定了一套web服务器执行脚本并返回结果的标准， 后来这套标准发展出了<a href="http://tools.ietf.org/html/rfc3875">CGI标准</a>。  <br/>
每次执行CGI脚本都需要新建一个进程（fork-and-execute），在这个进程还可能需要加载解释器之类的动作，所以代价比较高，如果短时间cgi访问较多的话，会很容器使得系统资源耗尽。</p>

<p><a href="http://www.fastcgi.com/drupal/node/6?q=node/15">FastCGI</a>，是对CGI的一个优化(或者说是对CGI的一个扩展)，提出了FastCGI Server的概念，FastCGI Server在启动后会预先加载多个CGI解释器进程，用于等待请求，其实也就是多了一个进程池的概念。减少不必要的创建销毁CGI进程的代价。Web Server将环境信息以及请求的信息通过UNIX Domain Socket的方式（比如Web Server和FastCGI在同一个机器上） 或者tcp连接（FastCGI Server分布在不同的机器上），然后FastCGI处理好了以同样的方式的连接将内容返回给web server。
对于不同的语言，FastCGI Server 可能会有不同的语言的实现，这些FastCGI Server并提供相关的API接口供你的web app使用。   <br/>
<a href="http://www.python.ca/scgi/protocol.txt">SCGI</a>（Simple Common Gateway Interface），和FastCGI类似，不过简单的多，没有FastCGI用得多。     <br/>
<a href="http://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html">AJP</a>（Apache JServ Protocol，Apache 1.x通过mod_jk模块实现,2.0中直接集成了AJP Connector）它是一种二进制格式的传输协议，所以性能比较可观，一般后端为Java Servlet 容器，Apache Tomcat和Jetty这两个Servlet容器都支持AJP协议。    <br/>
以上的CGI，FastCGI，SCGI以及AJP这些都可以看做数据交换的协议，和语言无关的。   <br/>
<br>
现在再将视线往Web Application这边移一步，这里说说Python的情况，在2003 出现WSGI之前，你若要使用Python写一个Web程序，可以专门针对CGI或者FastCGI写，也可以针对mod_python（集成了python解释器）写，为了解决这种Python Web应用编写时API不一致的情况，提出了WSGI（Web Server Gateway Interface），在Web Server 和 Web App之间增加一个抽象层，使得Web App这边的接口得到统一。一般所谓的协议或者接口其实都需要两方，WSGI也不例外，分为WSGI Server端和WSGI App端，WSGI Server端也就是所谓的那个抽象层。
有了WSGI，我们写的Python Web App可以在所有的兼容WSGI的Server上跑起来了。在WSGI App这一层接口统一的另一个好处就使得是通用的Web组件成为可能，也就出现了所谓的Middleware中间件。</p>

<p><img width="300" height="170" src="http://ww4.sinaimg.cn/large/65cc0af7jw1e2zvhnjronj.jpg"/></p>

<p>WSGI Family</p>

<ul>
<li>2007 Rack,Ruby version</li>
<li>2008 Lua WSAPI,Lua version</li>
<li>2009 JSGI ,Javascript version</li>
<li>2009 PSGI,Perl version</li>
<li>2010 Hack,Haskell version</li>
</ul>


<blockquote><p><a href="http://en.wikipedia.org/wiki/Template:Web_server_interfaces">Web Server Interfaces</a></p></blockquote>

<p>而至于Java语言，其用于Web开发的标准为Servlet。目前Servelet已经发展到3.0版。
<br>
常用的网站部署方式
前端web server 比如Apache，nginx，lighttpd，HAproxy用来直接处理用户的请求以及给用户响应，如果是静态文件的请求，那么web server直接给用户静态文件，毕竟前端的web server一般都是c语言写的，效率较好。
而动态的部分，则由 web server转至后端的 app server进行处理，传送的方式可以是cgi，fastcgi，ajp，或者直接反向代理。
像Apache或者Nginx都可以通过一定的方式支持FastCGI。
比如一下方式可以作为某个Python Web App的部署方式：</p>

<pre><code>    Nginx/FastCGI &lt;----FastCGI----&gt; FastCGI/WSGI Server    
</code></pre>

<p>还有一种方式就是前端的Web Server只负责请求的转发，也就是反向代理的方式，后端的Web App Server本身就集成了Web Server的功能：</p>

<pre><code>    Nginx&lt;----反向代理----&gt;Web App Server Instance1
    ^
    |----反向代理----&gt;Web App Server Instance2
</code></pre>

<p><br></p>

<h4>四.Web Application</h4>

<p>Web Application的开发依赖于 web app server/framework，需要遵循相应的API。
一般Web App都分好几个层，表现层，业务逻辑层，持久层。</p>

<ul>
<li>表现层：用的比较多的就是模板引擎技术了，比如Java的Velocity，Python的Jinja，Node.js的Jade。模板引擎的模板一般都是使用相应的自定义的脚本语言写成，语法都还算简单，模板都有变量，支持循环，条件判断之类的。Render的过程就是将模板文件和变量集合进行合并渲染得到最终的页面内容。</li>
<li>业务逻辑层：这层其实就是根据具体的业务需求，调用持久层，得到数据并进行处理，为表现层准备好数据。</li>
<li>持久层：这层主要做的就是数据库访问。很多时候为了性能，都有数据库连接池的概念。</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>存同求异</title>
      <link href="http://geeklu.com/2013/03/seek-differences/"/>
      <pubDate>2013-03-20T00:00:00-07:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/03/seek-differences</guid>
      <content:encoded><![CDATA[<p>有时候，我们在定位一个问题的时候，容易陷入问题本身，最后问题的定位往往无疾而终。这个时候我们需要跳出问题，换个角度来定位问题。“存同求异”不失为一个好的笨方法。</p>

<blockquote><p>  问题:一个很大的项目，复杂的项目结构，庞大的代码体系，这个时候出现一个诡异的bug，断点调试加代码检查各种无果。这个时候不妨休息一下，换个角度定位问题</p></blockquote>

<p>问题定位:</p>

<ul>
<li>1.新建一个新的空白项目，使用一个简单的界面重现问题场景。如果一样存在问题，则很有可能是框架使用方式不对或者框架本身的bug被触发了；如果一样的操作场景在这个新的项目中没有问题，那说明原来项目中的一些代码或者配置产生了这样的问题。</li>
<li>2.将原来存在问题的项目拷贝一份出来，在这个项目中新建一个界面，同样通过简单的代码在这个新的界面中重现问题场景。如果不存在问题，和存在问题的地方代码进行对比，找出不同点；如果仍然存在问题，则将项目中的其他代码都删除，最终只留这个新建的界面，如果删除后运行没有问题，那么说明问题就是由这些删掉的文件中的某个引起的（比如Objc中的Category如果写的有问题就可能产生你意向不到的问题，因为Category会覆盖框架原先的行为），如果删除了问题还在，说明问题可能出现在项目的相关设置或者配置中。</li>
<li>3.逐渐缩小对比区域，找出问题所在</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>Core Text 入门</title>
      <link href="http://geeklu.com/2013/03/core-text/"/>
      <pubDate>2013-03-11T00:00:00-07:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/03/core-text</guid>
      <content:encoded><![CDATA[<blockquote><p>本文所涉及的代码你可以在这里下载到 <a href="https://github.com/kejinlu/CTTest">https://github.com/kejinlu/CTTest</a>，包含两个项目，一个Mac的NSTextView的测试项目，一个iOS的Core Text的测试项目</p></blockquote>

<h2>NSTextView和Attribued String</h2>

<hr />

<p>第一次接触苹果系的富文本编程是在写Mac平台上的一个输入框的时候，输入框中的文字可以设置各种样式，并可以在文字中间插入图片，好在Mac的AppKit中提供了NSTextView这个支持富文本编辑器控件。此控件背后是通过什么方式来描述富文本的呢？答案是NSAttributedString，很多编程语言都提供了AttributedString的概念。NSAttributedString比NSString多了一个Attribute的概念，一个NSAttributedString的对象包含很多的属性，每一个属性都有其对应的字符区域，在这里是使用NSRange来进行描述的。下面是一个NSTextView显示富文本的例子</p>

<div class="highlight"><pre><code class="objc"><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="n">attributedString</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">NSMutableAttributedString</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithString</span><span class="o">:</span><span class="s">@&quot;测试富文本显示&quot;</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
<span class="c1">//为所有文本设置字体</span>
<span class="p">[</span><span class="n">attributedString</span> <span class="n">addAttribute</span><span class="o">:</span><span class="n">NSFontAttributeName</span> <span class="n">value</span><span class="o">:</span><span class="p">[</span><span class="n">NSFont</span> <span class="n">systemFontOfSize</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="n">range</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">attributedString</span> <span class="n">length</span><span class="p">])];</span>
<span class="c1">//将“测试”两字字体颜色设置为蓝色</span>
<span class="p">[</span><span class="n">attributedString</span> <span class="n">addAttribute</span><span class="o">:</span><span class="n">NSForegroundColorAttributeName</span> <span class="n">value</span><span class="o">:</span><span class="p">[</span><span class="n">NSColor</span> <span class="n">blueColor</span><span class="p">]</span> <span class="n">range</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)];</span>
<span class="c1">//将“富文本”三个字字体颜色设置为红色</span>
<span class="p">[</span><span class="n">attributedString</span> <span class="n">addAttribute</span><span class="o">:</span><span class="n">NSForegroundColorAttributeName</span> <span class="n">value</span><span class="o">:</span><span class="p">[</span><span class="n">NSColor</span> <span class="n">redColor</span><span class="p">]</span> <span class="n">range</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)];</span>
    
<span class="c1">//在“测”和“试”两字之间插入一张图片</span>
<span class="n">NSString</span> <span class="o">*</span><span class="n">imageName</span> <span class="o">=</span> <span class="s">@&quot;taobao.png&quot;</span><span class="p">;</span>
<span class="n">NSFileWrapper</span> <span class="o">*</span><span class="n">imageFileWrapper</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">NSFileWrapper</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initRegularFileWithContents</span><span class="o">:</span><span class="p">[[</span><span class="n">NSImage</span> <span class="n">imageNamed</span><span class="o">:</span><span class="n">imageName</span><span class="p">]</span> <span class="n">TIFFRepresentation</span><span class="p">]]</span> <span class="n">autorelease</span><span class="p">];</span>
<span class="n">imageFileWrapper</span><span class="p">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">imageName</span><span class="p">;</span>
<span class="n">imageFileWrapper</span><span class="p">.</span><span class="n">preferredFilename</span> <span class="o">=</span> <span class="n">imageName</span><span class="p">;</span>
    
<span class="n">NSTextAttachment</span> <span class="o">*</span><span class="n">imageAttachment</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">NSTextAttachment</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithFileWrapper</span><span class="o">:</span><span class="n">imageFileWrapper</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
<span class="n">NSAttributedString</span> <span class="o">*</span><span class="n">imageAttributedString</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSAttributedString</span> <span class="n">attributedStringWithAttachment</span><span class="o">:</span><span class="n">imageAttachment</span><span class="p">];</span>
<span class="p">[</span><span class="n">attributedString</span> <span class="n">insertAttributedString</span><span class="o">:</span><span class="n">imageAttributedString</span> <span class="n">atIndex</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm">其实插入图片附件之后 attributedString的长度增加了1 变成了8，所以可以预见其实图片附件属性对应的内容应该是一个长度的字符</span>
<span class="cm">Printing description of attributedString:</span>
<span class="cm">测{</span>
<span class="cm">    NSColor = &quot;NSCalibratedRGBColorSpace 0 0 1 1&quot;;</span>
<span class="cm">    NSFont = &quot;\&quot;LucidaGrande 24.00 pt. P [] (0x10051bfd0) fobj=0x101e687f0, spc=7.59\&quot;&quot;;</span>
<span class="cm">}￼{</span>
<span class="cm">    NSAttachment = &quot;&lt;NSTextAttachment: 0x101e0c9c0&gt; \&quot;taobao.png\&quot;&quot;;</span>
<span class="cm">}试{</span>
<span class="cm">    NSColor = &quot;NSCalibratedRGBColorSpace 0 0 1 1&quot;;</span>
<span class="cm">    NSFont = &quot;\&quot;LucidaGrande 24.00 pt. P [] (0x10051bfd0) fobj=0x101e687f0, spc=7.59\&quot;&quot;;</span>
<span class="cm">}富文本{</span>
<span class="cm">    NSColor = &quot;NSCalibratedRGBColorSpace 1 0 0 1&quot;;</span>
<span class="cm">    NSFont = &quot;\&quot;LucidaGrande 24.00 pt. P [] (0x10051bfd0) fobj=0x101e687f0, spc=7.59\&quot;&quot;;</span>
<span class="cm">}显示{</span>
<span class="cm">    NSFont = &quot;\&quot;LucidaGrande 24.00 pt. P [] (0x10051bfd0) fobj=0x101e687f0, spc=7.59\&quot;&quot;;</span>
<span class="cm">}</span>
<span class="cm">*/</span>


<span class="p">[</span><span class="n">_textView</span> <span class="n">insertText</span><span class="o">:</span><span class="n">attributedString</span><span class="p">];</span>
</code></pre></div>


<p><img src="http://ww1.sinaimg.cn/bmiddle/65cc0af7gw1e2rnc6to9cj.jpg" alt="" /></p>

<p>还有就是NSAttributedString提供对所有属性进行遍历的方法，也提供了计算在特定size下渲染实际所占的区域（boundingRectWithSize:options:） 这些这里就不介绍了。
从上面的代码可以看出其实Mac下的富文本的渲染并不是很复杂，只要将Attributed String理解和使用好，其余的事情都交给NSTextView来做了，你完全不用考虑其底层是如何取渲染的。但是在iOS平台上就没有这么幸运了，虽然iOS从3。2开始也提供了NSAttributedString，但是并没有类似NSTextView这样的控件直接来渲染Attributed String。
这个时候你就得使用Core Text了。</p>

<p><br/>
<br/></p>

<h2>Core Text</h2>

<hr />

<p>下面讨论的Core Text相关编程都是特指在iOS平台下。
Core Text是和Core Graphics配合使用的，一般是在UIView的drawRect方法中的Graphics Context上进行绘制的。
且Core Text真正负责绘制的是文本部分，图片还是需要自己去手动绘制，所以你必须关注很多绘制的细节部分。</p>

<h3>一.Core Text知识准备</h3>

<p>在进入任何一个新的编程领域之前，我们肯定要先接触相关的领域模型的知识。比如你软件是进行科学计算的，那么你就必须理解大量的数学原理；如果你的软件是搞银行系统，那么你就得事先了解相关的银行的业务知识。这些都是不可避免的事情。通常情况下领域知识具有较高的通用性。但在特定的环境下，某些知识点也会被特殊处理。
Core Text是用来进行文字精细排版的，所以了解文字相关的知识也不可避免。</p>

<h4>1.字符（Character）和字形（Glyphs）</h4>

<p>排版系统中文本显示的一个重要的过程就是字符到字形的转换，字符是信息本身的元素，而字形是字符的图形表征，字符还会有其它表征比如发音。
字符在计算机中其实就是一个编码，某个字符集中的编码，比如Unicode字符集，就囊括了大都数存在的字符。
而字形则是图形，一般都存储在字体文件中，字形也有它的编码，也就是它在字体中的索引。
一个字符可以对应多个字形（不同的字体，或者同种字体的不同样式:粗体斜体等）；多个字符也可能对应一个字形，比如字符的连写（ Ligatures）。 <br/>
<img src="http://ww1.sinaimg.cn/large/65cc0af7gw1e2u5ypr899g.gif" alt="" />  <br/>
Roman Ligatures</p>

<p>下面就来详情看看字形的各个参数也就是所谓的字形度量Glyph Metrics</p>

<p><img src="http://ww3.sinaimg.cn/large/65cc0af7jw1e2ucdlrkfbg.gif" alt="" />    <br/>
<img src="http://ww2.sinaimg.cn/large/65cc0af7gw1e2u242uytyg.gif" alt="" /></p>

<ul>
<li>bounding box（边界框 bbox），这是一个假想的框子，它尽可能紧密的装入字形。</li>
<li>baseline（基线），一条假想的线,一行上的字形都以此线作为上下位置的参考，在这条线的左侧存在一个点叫做基线的原点，</li>
<li>ascent（上行高度）从原点到字体中最高（这里的高深都是以基线为参照线的）的字形的顶部的距离，ascent是一个正值</li>
<li>descent（下行高度）从原点到字体中最深的字形底部的距离，descent是一个负值（比如一个字体原点到最深的字形的底部的距离为2，那么descent就为-2）</li>
<li>linegap（行距），linegap也可以称作leading（其实准确点讲应该叫做External leading）,行高lineHeight则可以通过 ascent + |descent| + linegap 来计算。</li>
</ul>


<p>一些Metrics专业知识还可以参考Free Type的文档 <a href="http://www.freetype.org/freetype2/docs/glyphs/glyphs-3.html">Glyph metrics</a>，其实iOS就是使用<a href="http://www.freetype.org/">Free Type</a>库来进行字体渲染的。</p>

<p>以上图片和部分概念来自苹果文档 <a href="http://developer.apple.com/library/mac/#documentation/TextFonts/Conceptual/CocoaTextArchitecture/FontHandling/FontHandling.html#//apple_ref/doc/uid/TP40009459-CH5-SW18">Querying Font Metrics</a> ，<a href="http://developer.apple.com/library/mac/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TypoFeatures/TextSystemFeatures.html#//apple_ref/doc/uid/TP40009459-CH6-51627-BBCCHIFF">Text Layout</a></p>

<h4>2.坐标系</h4>

<p>首先不得不说 苹果编程中的坐标系花样百出，经常让开发者措手不及。
传统的Mac中的坐标系的原点在左下角，比如NSView默认的坐标系，原点就在左下角。但Mac中有些View为了其实现的便捷将原点变换到左上角，像NSTableView的坐标系坐标原点就在左上角。iOS UIKit的UIView的坐标系原点在左上角。 <br/>
往底层看，Core Graphics的context使用的坐标系的原点是在左下角。而在iOS中的底层界面绘制就是通过Core Graphics进行的，那么坐标系列是如何变换的呢？
在UIView的drawRect方法中我们可以通过UIGraphicsGetCurrentContext()来获得当前的Graphics Context。drawRect方法在被调用前，这个Graphics Context被创建和配置好，你只管使用便是。如果你细心，通过CGContextGetCTM(CGContextRef c)可以看到其返回的值并不是CGAffineTransformIdentity，通过打印出来看到值为</p>

<pre><code>Printing description of contextCTM:
(CGAffineTransform) contextCTM = {
        a = 1
        b = 0
        c = 0
        d = -1
        tx = 0
        ty = 460
}       
</code></pre>

<p>这是非retina分辨率下的结果，如果是如果是retina上面的a,d,ty的值将会乘2，如果是iPhone 5，ty的值会再大些。
但是作用都是一样的就是将上下文空间坐标系进行了flip，使得原本左下角原点变到左上角，y轴正方向也变换成向下。</p>

<p>上面说了一大堆，下面进入正题，Core Text一开始便是定位于桌面的排版系统，使用了传统的原点在左下角的坐标系，所以它在绘制文本的时候都是参照左下角的原点进行绘制的。
但是iOS的UIView的drawRect方法的context被做了次flip，如果你啥也不做处理，直接在这个context上进行Core Text绘制，你会发现文字是镜像且上下颠倒。  <br/>
<img src="http://ww4.sinaimg.cn/large/65cc0af7gw1e2uwkpr6rfj.jpg" alt="" />  <br/>
所以在UIView的drawRect方法中的context上进行Core Text绘制之前需要对context进行一次Flip。    <br/>
<img src="http://ww1.sinaimg.cn/large/65cc0af7gw1e2uwlh7zvej.jpg" alt="" /></p>

<p>这里再提及一个函数CGContextSetTextMatrix，它可以用来为每一个显示的字形单独设置变形矩阵。</p>

<h4>3.NSMutableAttributedString 和 CFMutableAttributedStringRef</h4>

<p>Core Foundation和Foundation中的有些数据类型只需要简单的强制类型转换就可以互换使用，这类类型我们叫他们为<a href="http://developer.apple.com/library/mac/#documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html">Toll-Free Bridged Types</a>。 <br/>
CFMutableAttributedStringRef和NSMutableAttributedString就是其中的一对，Core Foundation的接口基本是C的接口，功能强大，但是使用起来没有Foundation中提供的Objc的接口简单好使，所以很多时候我们可以使用高层接口组织数据，然后将其传给低层函数接口使用。</p>

<h3>二.Core Text对象模型</h3>

<p>这节主要来看看Core Text绘制的一些细节问题了，首先是Core Text绘制的流程： <br/>
<img src="http://ww1.sinaimg.cn/large/65cc0af7gw1e2uxd1gmhwj.jpg" alt="" /></p>

<p><img src="http://ww4.sinaimg.cn/large/65cc0af7gw1e2uyn6r88oj.jpg" alt="" /></p>

<ul>
<li>framesetter  framesetter对应的类型是 CTFramesetter，通过CFAttributedString进行初始化，它作为CTFrame对象的生产工厂，负责根据path生产对应的CTFrame</li>
<li>CTFrame CTFrame是可以通过CTFrameDraw函数直接绘制到context上的，当然你可以在绘制之前，操作CTFrame中的CTLine，进行一些参数的微调</li>
<li>CTLine 可以看做Core Text绘制中的一行的对象 通过它可以获得当前行的line ascent,line descent ,line leading,还可以获得Line下的所有Glyph Runs</li>
<li>CTRun 或者叫做 Glyph Run，是一组共享想相同attributes（属性）的字形的集合体</li>
</ul>


<p>上面说了这么多对也没一个东西和图片绘制有关系，其实吧，Core Text本身并不支持图片绘制，图片的绘制你还得通过Core Graphics来进行。只是Core Text可以通过CTRun的设置为你的图片在文本绘制的过程中留出适当的空间。这个设置就使用到CTRunDelegate了，看这个名字大概就可以知道什么意思了，CTRunDelegate作为CTRun相关属性或操作扩展的一个入口，使得我们可以对CTRun做一些自定义的行为。为图片留位置的方法就是加入一个空白的CTRun，自定义其ascent，descent，width等参数，使得绘制文本的时候留下空白位置给相应的图片。然后图片在相应的空白位置上使用Core Graphics接口进行绘制。 <br/>
使用CTRunDelegateCreate可以创建一个CTRunDelegate，它接收两个参数，一个是callbacks结构体，一个是所有callback调用的时候需要传入的对象。
callbacks的结构体为CTRunDelegateCallbacks，主要是包含一些回调函数，比如有返回当前run的ascent，descent，width这些值的回调函数，至于函数中如何鉴别当前是哪个run，可以在CTRunDelegateCreate的第二个参数来达到目的，因为CTRunDelegateCreate的第二个参数会作为每一个回调调用时的入参。</p>

<h3>三.Core Text实战</h3>

<p>这里使用Core Text实现一个和之前NSTextView显示类似的图文混排的例子。</p>

<p><img src="http://ww4.sinaimg.cn/large/65cc0af7gw1e2v3mj0xsrj.jpg" alt="" /></p>

<p>直接贴上代码大家体会下:</p>

<div class="highlight"><pre><code class="objc"><span class="kt">void</span> <span class="nf">RunDelegateDeallocCallback</span><span class="p">(</span> <span class="kt">void</span><span class="o">*</span> <span class="n">refCon</span> <span class="p">){</span>
    
<span class="p">}</span>

<span class="n">CGFloat</span> <span class="nf">RunDelegateGetAscentCallback</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span><span class="n">refCon</span> <span class="p">){</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">imageName</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">refCon</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">UIImage</span> <span class="n">imageNamed</span><span class="o">:</span><span class="n">imageName</span><span class="p">].</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">CGFloat</span> <span class="nf">RunDelegateGetDescentCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">refCon</span><span class="p">){</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">CGFloat</span> <span class="nf">RunDelegateGetWidthCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">refCon</span><span class="p">){</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">imageName</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">refCon</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">UIImage</span> <span class="n">imageNamed</span><span class="o">:</span><span class="n">imageName</span><span class="p">].</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span>
<span class="p">{</span>
    <span class="n">CGContextRef</span> <span class="n">context</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
    
    <span class="c1">//这四行代码只是简单测试drawRect中context的坐标系</span>
    <span class="n">CGContextSetRGBFillColor</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">CGContextFillRect</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CGRectMake</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">100</span> <span class="p">));</span>
    <span class="n">CGContextSetRGBFillColor</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">.5</span><span class="p">);</span>
    <span class="n">CGContextFillRect</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CGRectMake</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">));</span>
    
    <span class="n">CGContextSetTextMatrix</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CGAffineTransformIdentity</span><span class="p">);</span><span class="c1">//设置字形变换矩阵为CGAffineTransformIdentity，也就是说每一个字形都不做图形变换</span>
    
    <span class="n">CGAffineTransform</span> <span class="n">flipVertical</span> <span class="o">=</span> <span class="n">CGAffineTransformMake</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
    <span class="n">CGContextConcatCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">flipVertical</span><span class="p">);</span><span class="c1">//将当前context的坐标系进行flip</span>
    
    <span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="n">attributedString</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">NSMutableAttributedString</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithString</span><span class="o">:</span><span class="s">@&quot;测试富文本显示&quot;</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
    
    <span class="c1">//为所有文本设置字体</span>
    <span class="c1">//[attributedString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:24] range:NSMakeRange(0, [attributedString length])]; // 6.0+</span>
    <span class="n">UIFont</span> <span class="o">*</span><span class="n">font</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIFont</span> <span class="n">systemFontOfSize</span><span class="o">:</span><span class="mi">24</span><span class="p">];</span>
    <span class="n">CTFontRef</span> <span class="n">fontRef</span> <span class="o">=</span> <span class="n">CTFontCreateWithName</span><span class="p">((</span><span class="n">CFStringRef</span><span class="p">)</span><span class="n">font</span><span class="p">.</span><span class="n">fontName</span><span class="p">,</span> <span class="n">font</span><span class="p">.</span><span class="n">pointSize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">[</span><span class="n">attributedString</span> <span class="n">addAttribute</span><span class="o">:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">kCTFontAttributeName</span> <span class="n">value</span><span class="o">:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">fontRef</span> <span class="n">range</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">attributedString</span> <span class="n">length</span><span class="p">])];</span>
    
    <span class="c1">//将“测试”两字字体颜色设置为蓝色</span>
    <span class="c1">//[attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(0, 2)]; //6.0+</span>
    <span class="p">[</span><span class="n">attributedString</span> <span class="n">addAttribute</span><span class="o">:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">kCTForegroundColorAttributeName</span> <span class="n">value</span><span class="o">:</span><span class="p">(</span><span class="kt">id</span><span class="p">)[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="n">CGColor</span> <span class="n">range</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)];</span>
    
    <span class="c1">//将“富文本”三个字字体颜色设置为红色</span>
    <span class="c1">//[attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(2, 3)]; //6.0+</span>
    <span class="p">[</span><span class="n">attributedString</span> <span class="n">addAttribute</span><span class="o">:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">kCTForegroundColorAttributeName</span> <span class="n">value</span><span class="o">:</span><span class="p">(</span><span class="kt">id</span><span class="p">)[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span> <span class="n">range</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)];</span>
    
    
    <span class="c1">//为图片设置CTRunDelegate,delegate决定留给图片的空间大小</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">taobaoImageName</span> <span class="o">=</span> <span class="s">@&quot;taobao.png&quot;</span><span class="p">;</span>
    <span class="n">CTRunDelegateCallbacks</span> <span class="n">imageCallbacks</span><span class="p">;</span>
    <span class="n">imageCallbacks</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">kCTRunDelegateVersion1</span><span class="p">;</span>
    <span class="n">imageCallbacks</span><span class="p">.</span><span class="n">dealloc</span> <span class="o">=</span> <span class="n">RunDelegateDeallocCallback</span><span class="p">;</span>
    <span class="n">imageCallbacks</span><span class="p">.</span><span class="n">getAscent</span> <span class="o">=</span> <span class="n">RunDelegateGetAscentCallback</span><span class="p">;</span>
    <span class="n">imageCallbacks</span><span class="p">.</span><span class="n">getDescent</span> <span class="o">=</span> <span class="n">RunDelegateGetDescentCallback</span><span class="p">;</span>
    <span class="n">imageCallbacks</span><span class="p">.</span><span class="n">getWidth</span> <span class="o">=</span> <span class="n">RunDelegateGetWidthCallback</span><span class="p">;</span>
    <span class="n">CTRunDelegateRef</span> <span class="n">runDelegate</span> <span class="o">=</span> <span class="n">CTRunDelegateCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imageCallbacks</span><span class="p">,</span> <span class="n">taobaoImageName</span><span class="p">);</span>
    <span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="n">imageAttributedString</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableAttributedString</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithString</span><span class="o">:</span><span class="s">@&quot; &quot;</span><span class="p">];</span><span class="c1">//空格用于给图片留位置</span>
    <span class="p">[</span><span class="n">imageAttributedString</span> <span class="n">addAttribute</span><span class="o">:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">kCTRunDelegateAttributeName</span> <span class="n">value</span><span class="o">:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">runDelegate</span> <span class="n">range</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
    <span class="n">CFRelease</span><span class="p">(</span><span class="n">runDelegate</span><span class="p">);</span>
    
    <span class="p">[</span><span class="n">imageAttributedString</span> <span class="n">addAttribute</span><span class="o">:</span><span class="s">@&quot;imageName&quot;</span> <span class="n">value</span><span class="o">:</span><span class="n">taobaoImageName</span> <span class="n">range</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
    
    <span class="p">[</span><span class="n">attributedString</span> <span class="n">insertAttributedString</span><span class="o">:</span><span class="n">imageAttributedString</span> <span class="n">atIndex</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
    
    <span class="n">CTFramesetterRef</span> <span class="n">ctFramesetter</span> <span class="o">=</span> <span class="n">CTFramesetterCreateWithAttributedString</span><span class="p">((</span><span class="n">CFMutableAttributedStringRef</span><span class="p">)</span><span class="n">attributedString</span><span class="p">);</span>
    
    <span class="n">CGMutablePathRef</span> <span class="n">path</span> <span class="o">=</span> <span class="n">CGPathCreateMutable</span><span class="p">();</span>
    <span class="n">CGRect</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
    <span class="n">CGPathAddRect</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bounds</span><span class="p">);</span>
    
    <span class="n">CTFrameRef</span> <span class="n">ctFrame</span> <span class="o">=</span> <span class="n">CTFramesetterCreateFrame</span><span class="p">(</span><span class="n">ctFramesetter</span><span class="p">,</span><span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">CTFrameDraw</span><span class="p">(</span><span class="n">ctFrame</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
    
    <span class="n">CFArrayRef</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">CTFrameGetLines</span><span class="p">(</span><span class="n">ctFrame</span><span class="p">);</span>
    <span class="n">CGPoint</span> <span class="n">lineOrigins</span><span class="p">[</span><span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">lines</span><span class="p">)];</span>
    <span class="n">CTFrameGetLineOrigins</span><span class="p">(</span><span class="n">ctFrame</span><span class="p">,</span> <span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">lineOrigins</span><span class="p">);</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">lines</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">CTLineRef</span> <span class="n">line</span> <span class="o">=</span> <span class="n">CFArrayGetValueAtIndex</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">CGFloat</span> <span class="n">lineAscent</span><span class="p">;</span>
        <span class="n">CGFloat</span> <span class="n">lineDescent</span><span class="p">;</span>
        <span class="n">CGFloat</span> <span class="n">lineLeading</span><span class="p">;</span>
        <span class="n">CTLineGetTypographicBounds</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lineAscent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lineDescent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lineLeading</span><span class="p">);</span>
        
        <span class="n">CFArrayRef</span> <span class="n">runs</span> <span class="o">=</span> <span class="n">CTLineGetGlyphRuns</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">runs</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">CGFloat</span> <span class="n">runAscent</span><span class="p">;</span>
            <span class="n">CGFloat</span> <span class="n">runDescent</span><span class="p">;</span>
            <span class="n">CGPoint</span> <span class="n">lineOrigin</span> <span class="o">=</span> <span class="n">lineOrigins</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">CTRunRef</span> <span class="n">run</span> <span class="o">=</span> <span class="n">CFArrayGetValueAtIndex</span><span class="p">(</span><span class="n">runs</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="n">NSDictionary</span><span class="o">*</span> <span class="n">attributes</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSDictionary</span><span class="o">*</span><span class="p">)</span><span class="n">CTRunGetAttributes</span><span class="p">(</span><span class="n">run</span><span class="p">);</span>
            <span class="n">CGRect</span> <span class="n">runRect</span><span class="p">;</span>
            <span class="n">runRect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">CTRunGetTypographicBounds</span><span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">runAscent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">runDescent</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            
            <span class="n">runRect</span><span class="o">=</span><span class="n">CGRectMake</span><span class="p">(</span><span class="n">lineOrigin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">CTLineGetOffsetForStringIndex</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">CTRunGetStringRange</span><span class="p">(</span><span class="n">run</span><span class="p">).</span><span class="n">location</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span> <span class="n">lineOrigin</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">runDescent</span><span class="p">,</span> <span class="n">runRect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">runAscent</span> <span class="o">+</span> <span class="n">runDescent</span><span class="p">);</span>
            
            <span class="n">NSString</span> <span class="o">*</span><span class="n">imageName</span> <span class="o">=</span> <span class="p">[</span><span class="n">attributes</span> <span class="n">objectForKey</span><span class="o">:</span><span class="s">@&quot;imageName&quot;</span><span class="p">];</span>
            <span class="c1">//图片渲染逻辑</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">imageName</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="n">imageNamed</span><span class="o">:</span><span class="n">imageName</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">CGRect</span> <span class="n">imageDrawRect</span><span class="p">;</span>
                    <span class="n">imageDrawRect</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
                    <span class="n">imageDrawRect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">runRect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">lineOrigin</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
                    <span class="n">imageDrawRect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">lineOrigin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
                    <span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">imageDrawRect</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">CFRelease</span><span class="p">(</span><span class="n">ctFrame</span><span class="p">);</span>
    <span class="n">CFRelease</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
    <span class="n">CFRelease</span><span class="p">(</span><span class="n">ctFramesetter</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>



]]></content:encoded>
    </item>
    
    <item>
      <title>浅谈Gitosis实现原理</title>
      <link href="http://geeklu.com/2012/10/gitosis/"/>
      <pubDate>2012-10-09T00:00:00-07:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2012/10/gitosis</guid>
      <content:encoded><![CDATA[<p>git作为一个分布式的版本控制系统,其实client端和server的差别并不是很大，只是server端往往没有工作拷贝的需求，所以往往是一个裸库（bare repository），往往文件夹的名称为xxxx.git ，裸库的内容其实就相当于客户端某个工程下的.git目录了.     <br/>
<br>
使用git的时候，一般和服务器通讯使用的是ssh协议，用ssh的主要优点是速度快（传输前数据会先压缩，比HTTP快），安全，方便读写。
客户端通过ssh访问服务器端的验证方式一般有两种，一种是用户名密码的方式，一种是使用公私钥认证的方式.
使用公私钥的方式比较方便，无需每次登录输入密码。
某个受信任的客户端的公钥会被设置在服务器端的 ~/.ssh/authorized_keys文件中，有关此文件的格式可以参见 sshd的用户手册  <code>man sshd</code> . authorized_keys有个比较厉害的功能是 支持 command参数，使得每次用户使用此公钥进行验证的时候执行此后面的命令.这样就可以做一些逻辑处理了.   <br/>
<br>
一般git库的管理需要权限控制，如何方便简单的进行库的权限管理呢？ authorized_keys是一个思路，指定特定command参数，每次验证好用户后首先执行相关逻辑，检测当前用户是否具有某个权限。
所以便有了gitosis，与其说gitosis是一个git权限管理系统，还不如说它是一个authorized_keys文件管理器.   <br/>
gitosis的设计思路很巧妙，开天辟地之初，需要一个gitosis的管理员，所以你就在你的客户端机器上生成一对公私钥，将公钥拷贝到git服务器端的/tmp/下，然后通过gitosis在git用户home目录下运行如下初始化命令，后面的公钥便是gitosis首个管理员的公钥</p>

<div class="highlight"><pre><code class="bash">sudo -H -u git gitosis-init &lt; /tmp/id_rsa.pub
</code></pre></div>


<p>执行之后，home目录下出现一个repositories的目录，目录下存在一个gitosis-admin.git的git库. 其实gitosis就是通过这个git库来管理所有git库的访问权限的。  <br/>
在刚才你的客户端机器上clone出这个库，因为你刚刚用你的公钥初始化了gitosis，所以你有权限访问服务器端的库（其实你可以在服务器端看看authorized_keys文件便知道原因了）。
这个gitosis-admin的库中存在一个gitosis.conf和一个keydir的目录，gitosis.conf文件就是权限配置的地方，keydir目录下存放的是所有客户端的公钥，公钥名字必须和配置文件中的member名字对应.至于gitosis.conf的语法及用法可以去查看帮助。 <br/>
当修改完配置和添加好需要添加的公钥之后，提交并push到git服务器，这个库的存在hook，当提交后，会根据新的配置和公钥去更新服务器端git用户的authorized_keys，以便加入新用户的公钥，用于权限控制命令，以及在裸库的目录下提取出新的gitosis.conf文件。<br/>
<br>
所以 gitosis的核心在于authorized_keys的command参数和git的hook功能.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>谈谈iOS Animation</title>
      <link href="http://geeklu.com/2012/09/animation-in-ios/"/>
      <pubDate>2012-09-26T00:00:00-07:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2012/09/animation-in-ios</guid>
      <content:encoded><![CDATA[<h3>零.前言</h3>

<p> 这里没有太多的代码细节,只是探索iOS动画的基本概念,以及其抽象模型,数学基础等.我们学习一个知识的时候一般有两个部分,抽象部分和形象部分,抽象好比语言的语法,是规则,形象好比具体的句子,可以用来和别人交流的.抽象比形象难于理解,但比形象通用.其实数学中经常碰到抽象和形象的概念,比如有一系列离散的点,这是形象;通过这些点我们拟合出一条曲线,得到其函数,函数是抽象的;然后通过这个函数我们可以得到更多的点,这又回到了形象上.所以学习任何知识不能仅仅停留在会用了,而要上升一个层次,去学习研究其抽象层次上的知识,抽象层度越高,则越通用.</p>

<h3>一.基本概念</h3>

<p>什么是Animation(动画),简单点说就是在一段时间内,显示的内容发生了变化.对CALayer来说就是在一段时间内,其Animatable Property发生了变化.从CALayer(CA = Core Animation)类名来看就可以看出iOS的Layer就是为动画而生的,便于实现良好的交互体验.
这里涉及到两个东西: 一是Layer(基类CALayer),一是Animation(基于CAAnimation). Animation作用于Layer.CALayer提供了接口用于给自己添加Animation.
用于显示的Layer本质上讲是一个Model,包含了Layer的各种属性值.
Animation则包含了动画的时间,变化,以及变化的速度.下面分别详细讲解Layer和Animation相关知识.</p>

<h3>二.CALayer及时间模型</h3>

<p>我们都知道UIView是MVC中的View.UIView的职责在于界面的显示和界面事件的处理.每一个View的背后都有一个layer(可以通过view.layer进行访问),layer是用于界面显示的.CALayer属于QuartzCore框架,非常重要,但并没有想象中的那么好理解.我们通常操作的用于显示的Layer在Core Animation这层的概念中其实担当的是数据模型Model的角色,它并不直接做渲染的工作.关于Layer,之前从座标系的角度分析过,这次则侧重于它的时间系统.</p>

<h4>1.Layer的渲染架构</h4>

<p>Layer也和View一样存在着一个层级树状结构,称之为图层树(Layer Tree),直接创建的或者通过UIView获得的(view.layer)用于显示的图层树,称之为模型树(Model Tree),模型树的背后还存在两份图层树的拷贝,一个是呈现树(Presentation Tree),一个是渲染树(Render Tree).
呈现树可以通过普通layer(其实就是模型树)的layer.presentationLayer获得,而模型树则可以通过modelLayer属性获得(详情文档).模型树的属性在其被修改的时候就变成了新的值,这个是可以用代码直接操控的部分;呈现树的属性值和动画运行过程中界面上看到的是一致的.而渲染树是私有的,你无法访问到,渲染树是对呈现树的数据进行渲染,为了不阻塞主线程,渲染的过程是在单独的进程或线程中进行的,所以你会发现Animation的动画并不会阻塞主线程.</p>

<h4>2.事务管理</h4>

<p>CALayer的那些可用于动画的(Animatable)属性,称之为Animatable Properties,这里有一份详情的列表,罗列了所有的 <a href="http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreAnimation_guide/Articles/AnimProps.html">CALayer Animatable Properties</a>.
如果一个Layer对象存在对应着的View,则称这个Layer是一个Root Layer,非Root Layer一般都是通过CALayer或其子类直接创建的.下面的subLayer就是一个典型的非Root Layer,它没有对应的View对象关联着.</p>

<div class="highlight"><pre><code class="objc">    <span class="n">subLayer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="n">subLayer</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
    <span class="n">subLayer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span> <span class="n">CGColor</span><span class="p">];</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="n">addSublayer</span><span class="o">:</span><span class="n">subLayer</span><span class="p">];</span>
</code></pre></div>


<p>所有的非Root Layer在设置Animatable Properties的时候都存在着隐式动画,默认的duration是0.25秒.</p>

<div class="highlight"><pre><code class="objc">    <span class="n">subLayer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span><span class="mi">400</span><span class="p">);</span>
</code></pre></div>


<p>像上面这段代码当下一个RunLoop开始的时候并不是直接将subLayer的position变成(300,400)的,而是有个移动的动画进行过渡完成的.</p>

<p>任何Layer的animatable属性的设置都应该属于某个CA事务(CATransaction),事务的作用是为了保证多个animatable属性的变化同时进行,不管是同一个layer还是不同的layer之间的.CATransaction也分两类,显式的和隐式的,当在某次RunLoop中设置一个animatable属性的时候,如果发现当前没有事务,则会自动创建一个CA事务,在线程的下个RunLoop开始时自动commit这个事务,如果在没有RunLoop的地方设置layer的animatable属性,则必须使用显式的事务.</p>

<p>显式事务的使用如下：</p>

<div class="highlight"><pre><code class="objc"><span class="p">[</span><span class="n">CATransaction</span> <span class="n">begin</span><span class="p">];</span>
<span class="p">...</span>  
<span class="p">[</span><span class="n">CATransaction</span> <span class="n">commit</span><span class="p">];</span>
</code></pre></div>


<p>事务可以嵌套.当事务嵌套时候,只有当最外层的事务commit了之后,整个动画才开始.</p>

<p>可以通过CATransaction来设置一个事务级别的动画属性,覆盖隐式动画的相关属性,比如覆盖隐式动画的duration,timingFunction.如果是显式动画没有设置duration或者timingFunction,那么CA事务设置的这些参数也会对这个显式动画起作用.</p>

<p>还可以设置completionBlock,当当前CATransaction的所有动画执行结束后, completionBlock会被调用.</p>

<h4>3.时间系统</h4>

<p>CALayer实现了CAMediaTiming协议.
CALayer通过CAMediaTiming协议实现了一个有层级关系的时间系统.除了CALayer,CAAnimation也采纳了此协议,用来实现动画的时间系统.  <br/>
在CA中,有一个Absolute Time(绝对时间)的概念,可以通过CACurrentMediaTime()获得,其实这个绝对时间就是将mach_absolute_time()转换成秒后的值.这个时间和系统的uptime有关,系统重启后CACurrentMediaTime()会被重置. <br/>
就和座标存在相对座标一样,不同的实现了CAMediaTiming协议的存在层级关系的对象也存在相对时间,经常需要进行时间的转换,CALayer提供了两个时间转换的方法:</p>

<div class="highlight"><pre><code class="objc"><span class="k">-</span> <span class="p">(</span><span class="n">CFTimeInterval</span><span class="p">)</span><span class="nf">convertTime:</span><span class="p">(</span><span class="n">CFTimeInterval</span><span class="p">)</span><span class="nv">t</span> <span class="nf">fromLayer:</span><span class="p">(</span><span class="n">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="nv">l</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="n">CFTimeInterval</span><span class="p">)</span><span class="nf">convertTime:</span><span class="p">(</span><span class="n">CFTimeInterval</span><span class="p">)</span><span class="nv">t</span> <span class="nf">toLayer:</span><span class="p">(</span><span class="n">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="nv">l</span><span class="p">;</span>
</code></pre></div>


<p>现在来重点研究CAMediaTiming协议中几个重要的属性.</p>

<h4>beginTime</h4>

<p>无论是图层还是动画,都有一个时间线Timeline的概念,他们的beginTime是相对于父级对象的开始时间.
虽然苹果的文档中没有指明,但是通过代码测试可以发现,默认情况下所有的CALayer图层的时间线都是一致的,他们的beginTime都是0,绝对时间转换到当前Layer中的时间大小就是绝对时间的大小.所以对于图层而言,虽然创建有先后,但是他们的时间线都是一致的(只要不主动去修改某个图层的beginTime),所以我们可以想象成所有的图层默认都是从系统重启后开始了他们的时间线的计时.</p>

<p>但是动画的时间线的情况就不同了,当一个动画创建好,被加入到某个Layer的时候,会先被拷贝一份出来用于加入当前的图层,在CA事务被提交的时候,如果图层中的动画的beginTime为0,则beginTime会被设定为当前图层的当前时间,使得动画立即开始.如果你想某个直接加入图层的动画稍后执行,可以通过手动设置这个动画的beginTime,但需要注意的是这个beginTime需要为 CACurrentMediaTime()+延迟的秒数,因为beginTime是指其父级对象的时间线上的某个时间,这个时候动画的父级对象为加入的这个图层,图层当前的时间其实为[layer convertTime:CACurrentMediaTime() fromLayer:nil],其实就等于CACurrentMediaTime(),那么再在这个layer的时间线上往后延迟一定的秒数便得到上面的那个结果.</p>

<h4>timeOffset</h4>

<p>这个timeOffset可能是这几个属性中比较难理解的一个,官方的文档也没有讲的很清楚.
local time也分成两种一种是active local time 一种是basic local time.<br/>
timeOffset则是active local time的偏移量. <br/>
你将一个动画看作一个环,timeOffset改变的其实是动画在环内的起点,比如一个duration为5秒的动画,将timeOffset设置为2(或者7,模5为2),那么动画的运行则是从原来的2秒开始到5秒,接着再0秒到2秒,完成一次动画.</p>

<h4>speed</h4>

<p>speed属性用于设置当前对象的时间流相对于父级对象时间流的流逝速度,比如一个动画beginTime是0,但是speed是2,那么这个动画的1秒处相当于父级对象时间流中的2秒处.
speed越大则说明时间流逝速度越快,那动画也就越快.比如一个speed为2的layer其所有的父辈的speed都是1,它有一个subLayer,speed也为2,那么一个8秒的动画在这个运行于这个subLayer只需2秒(8 / (2 * 2)).所以speed有叠加的效果.</p>

<h4>fillMode</h4>

<p>fillMode的作用就是决定当前对象过了非active时间段的行为.
比如动画开始之前,动画结束之后。如果是一个动画CAAnimation,则需要将其removedOnCompletion设置为NO,要不然fillMode不起作用.
下面来讲各个fillMode的意义 <br/>
<strong>kCAFillModeRemoved</strong>  这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态 <br/>
<strong>kCAFillModeForwards</strong> 当动画结束后,layer会一直保持着动画最后的状态   <br/>
<strong>kCAFillModeBackwards</strong>  这个和kCAFillModeForwards是相对的,就是在动画开始前,你只要将动画加入了一个layer,layer便立即进入动画的初始状态并等待动画开始.你可以这样设定测试代码,将一个动画加入一个layer的时候延迟5秒执行.然后就会发现在动画没有开始的时候,只要动画被加入了layer,layer便处于动画初始状态  <br/>
<strong>kCAFillModeBoth</strong> 理解了上面两个,这个就很好理解了,这个其实就是上面两个的合成.动画加入后开始之前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态.</p>

<p>其他的一些参数都是比较容易理解的.</p>

<h4>实际应用</h4>

<p>参见苹果官方 QA1673 <a href="https://developer.apple.com/library/ios/#qa/qa2009/qa1673.html">How to pause the animation of a layer tree</a></p>

<div class="highlight"><pre><code class="objc"><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pauseLayer:</span><span class="p">(</span><span class="n">CALayer</span><span class="o">*</span><span class="p">)</span><span class="nv">layer</span>
<span class="p">{</span>
    <span class="n">CFTimeInterval</span> <span class="n">pausedTime</span> <span class="o">=</span> <span class="p">[</span><span class="n">layer</span> <span class="n">convertTime</span><span class="o">:</span><span class="n">CACurrentMediaTime</span><span class="p">()</span> <span class="n">fromLayer</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="n">layer</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">layer</span><span class="p">.</span><span class="n">timeOffset</span> <span class="o">=</span> <span class="n">pausedTime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">resumeLayer:</span><span class="p">(</span><span class="n">CALayer</span><span class="o">*</span><span class="p">)</span><span class="nv">layer</span>
<span class="p">{</span>
    <span class="n">CFTimeInterval</span> <span class="n">pausedTime</span> <span class="o">=</span> <span class="p">[</span><span class="n">layer</span> <span class="n">timeOffset</span><span class="p">];</span>
    <span class="n">layer</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="n">layer</span><span class="p">.</span><span class="n">timeOffset</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">layer</span><span class="p">.</span><span class="n">beginTime</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">CFTimeInterval</span> <span class="n">timeSincePause</span> <span class="o">=</span> <span class="p">[</span><span class="n">layer</span> <span class="n">convertTime</span><span class="o">:</span><span class="n">CACurrentMediaTime</span><span class="p">()</span> <span class="n">fromLayer</span><span class="o">:</span><span class="nb">nil</span><span class="p">]</span> <span class="o">-</span> <span class="n">pausedTime</span><span class="p">;</span>
    <span class="n">layer</span><span class="p">.</span><span class="n">beginTime</span> <span class="o">=</span> <span class="n">timeSincePause</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<h3>三.显式动画Animation</h3>

<p>当需要对非Root Layer进行动画或者需要对动画做更多自定义的行为的时候,就必须使用到显式动画了,显式动画的基类为CAAnimation,常用的是CABasicAnimation,CAKeyframeAnimation有时候还会使用到CAAnimationGroup,CATransition(注意不是CATransaction,Transition是过渡的意思). <br/>
<img src="http://ww1.sinaimg.cn/large/65cc0af7gw1dxlusbklpmj.jpg" alt="" /></p>

<p>这里再强调关于动画的两个重要的点:一是中间状态的插值计算(Interpolation),二是动画节奏控制(Timing); 有时候插值计算也和Timing有一定关系.
如果状态是一维空间的值(比如透明度),那么插值计算的结果必然再起点值和终点值之间,如果状态是二维空间的值(比如position),那么一般情况下插值得到的点会落在起点和终点之间的线段上（当然也有可能连线是圆滑曲线）.</p>

<h4>1.CABasicAnimation</h4>

<p>不管是CABasicAnimation还是CAKeyframeAnimation都是继承于CAPropertyAnimation.
<img src="http://ww4.sinaimg.cn/large/65cc0af7gw1dxlum1261zj.jpg" alt="" />
CABasicAnimation有三个比较重要的属性,fromValue,toValue,byValue,这三个属性都是可选的,但不能同时多于两个为非空.最终都是为了确定animation变化的起点和终点.<a href="http://developer.apple.com/library/ios/#documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004496-CH1-SW4">Setting Interpolation Values</a>详细介绍了这个三个值的各种情况以及用途.
设置了动画的起点和终点之后,中间的值都是通过插值方式计算出来的.插值计算的结果由timingFunction指定,默认timingFunction为nil,会使用liner的,也就是变化是均匀的.</p>

<h4>2.Timing Function的作用</h4>

<p>Timing Function的会被用于变化起点和终点之间的插值计算.形象点说是Timing Function决定了动画运行的节奏(Pacing),比如是均匀变化(相同时间变化量相同),先快后慢,先慢后快还是先慢再快再慢.</p>

<p>时间函数是使用的一段函数来描述的,横座标是时间t取值范围是0.0-1.0,纵座标是变化量x(t)也是取值范围也是0.0-1.0
假设有一个动画,duration是8秒,变化值的起点是a终点是b(假设是透明度),那么在4秒处的值是多少呢？
可以通过计算为 a + x(4/8) * (b-a), 为什么这么计算呢？讲实现的时间映射到单位值的时候4秒相对于总时间8秒就是0.5然后可以得到0.5的时候单位变化量是 x(0.5), x(0.5)/1 = 实际变化量/(b-a), 其中b-a为总变化量,所以实际变化量就是x(0.5) * (b-a) ,最后4秒时的值就是 a + x(0.5) * (b-a),所以计算的本质是映射.</p>

<p>Timing Function对应的类是CAMediaTimingFunction,它提供了两种获得时间函数的方式,一种是使用预定义的五种时间函数,一种是通过给点两个控制点得到一个时间函数.
相关的方法为</p>

<div class="highlight"><pre><code class="objc"><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">functionWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span><span class="p">;</span>

<span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">functionWithControlPoints:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nv">c1x</span> <span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">c1y</span> <span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">c2x</span> <span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">c2y</span><span class="p">;</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithControlPoints:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nv">c1x</span> <span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">c1y</span> <span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">c2x</span> <span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">c2y</span><span class="p">;</span>
</code></pre></div>


<p>五种预定义的时间函数名字的常量变量分别为  <br/>
kCAMediaTimingFunctionLinear,  <br/>
kCAMediaTimingFunctionEaseIn, <br/>
kCAMediaTimingFunctionEaseOut,  <br/>
kCAMediaTimingFunctionEaseInEaseOut,  <br/>
kCAMediaTimingFunctionDefault. <br/>
下图展示了前面四种Timing Function的曲线图,横座标表示时间,纵座标表示变化量,这点需要搞清楚(并不是平面座标系中xy).
<img src="http://ww1.sinaimg.cn/large/65cc0af7gw1dxlv7mhtj3j.jpg" alt="" /><br/>
自定义的Timing Function的函数图像就是一条三次贝塞尔曲线<a href="http://zh.wikipedia.org/zh-cn/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF">Cubic Bezier Curve</a>,贝塞尔曲线的优点就是光滑,用在这里就使得变化显得光滑.一条三次贝塞尔曲线可以由起点终点以及两个控制点决定.   <br/>
上面的kCAMediaTimingFunctionDefault对应的函数曲线其实就是通过[(0.0,0.0), (0.25,0.1), (0.25,0.1), (1.0,1.0)]这四个点决定的三次贝塞尔曲线,头尾为起点和终点,中间的两个点是控制点. <br/>
<img src="http://ww2.sinaimg.cn/large/65cc0af7gw1dxm21gxjr0j.jpg" alt="" />  <br/>
上图中P0是起点,P3是终点,P1和P2是两个控制点</p>

<p>如果时间变化曲线既不是直线也不是贝塞尔曲线,而是自定义的,又或者某个图层运动的轨迹不是直线而是一个曲线,这些是基本动画无法做到的,所以引入下面的内容,CAKeyframeAnimation,也即所谓的关键帧动画.</p>

<h4>3.CAKeyframeAnimation</h4>

<p>任何动画要表现出运动或者变化,至少需要两个不同的关键状态,而中间的状态的变化可以通过插值计算完成,从而形成补间动画,表示关键状态的帧叫做关键帧.
<img src="http://ww3.sinaimg.cn/large/65cc0af7gw1dxlv01a1jmj.jpg" alt="" />
CABasicAnimation其实可以看作一种特殊的关键帧动画,只有头尾两个关键帧.CAKeyframeAnimation则可以支持任意多个关键帧,关键帧有两种方式来指定,使用path或者使用values,path是一个CGPathRef的值,且path只能对CALayer的 anchorPoint 和 position 属性起作用,且设置了path之后values就不再起效了.而values则更加灵活.
keyTimes这个可选参数可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的. <br/>
还可以通过设置可选参数timingFunctions(CAKeyframeAnimation中timingFunction是无效的)为关键帧之间的过渡设置timingFunction,如果values有n个元素,那么timingFunctions则应该有n-1个.但很多时候并不需要timingFunctions,因为已经设置了够多的关键帧了,比如没1/60秒就设置了一个关键帧,那么帧率将达到60FPS,完全不需要相邻两帧的过渡效果（当然也有可能某两帧 值相距较大,可以使用均匀变化或者增加帧率,比如每0.01秒设置一个关键帧）.</p>

<p>在关键帧动画中还有一个非常重要的参数,那便是calculationMode,计算模式.其主要针对的是每一帧的内容为一个座标点的情况,也就是对anchorPoint 和 position 进行的动画.当在平面座标系中有多个离散的点的时候,可以是离散的,也可以直线相连后进行插值计算,也可以使用圆滑的曲线将他们相连后进行插值计算.
calculationMode目前提供如下几种模式
kCAAnimationLinear <br/>
kCAAnimationDiscrete <br/>
kCAAnimationPaced <br/>
kCAAnimationCubic <br/>
kCAAnimationCubicPaced</p>

<p><strong>kCAAnimationLinear</strong> calculationMode的默认值,表示当关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算;  <br/>
<strong>kCAAnimationDiscrete</strong> 离散的,就是不进行插值计算,所有关键帧直接逐个进行显示; <br/>
<strong>kCAAnimationPaced</strong> 使得动画均匀进行,而不是按keyTimes设置的或者按关键帧平分时间,此时keyTimes和timingFunctions无效;    <br/>
<strong>kCAAnimationCubic</strong> 对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,这里的数学原理是<a href="http://en.wikipedia.org/wiki/Kochanek-Bartels_spline">Kochanek–Bartels spline</a>,这里的主要目的是使得运行的轨迹变得圆滑;    <br/>
<strong>kCAAnimationCubicPaced</strong> 看这个名字就知道和kCAAnimationCubic有一定联系,其实就是在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,此时keyTimes以及timingFunctions也是无效的.</p>

<p><br>
最后推荐下WWDC 2010和2011上的关于Animation相关的Session,大家可以找找来看.2010的有说到Core Graphic相关内容.以及他们都从性能方面对CA做了些诠释.</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
